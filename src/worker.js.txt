// src/worker.js
// BETRIX ‚Äî Unified, smooth-as-butter worker
// Vision: ethical, neutral football assistant with modular payments and modern UX.
// Includes:
// - Futuristic menu with Back buttons and grouped commands
// - Command normalization, robust HTML escaping, safe chunking
// - Pagination with Prev/Next + Refresh + Back
// - Match data: live/today/next/league fixtures, standings
// - Inline actions: Analyze / Odds / Lineups
// - Payments: M-Pesa STK Push (+ webhook), PayPal (orders + subscriptions + webhook), Binance (manual verify)
// - Signup flow and payment menus integrated with Back buttons
// - Referrals: deep link, points, leaderboard, guard against self-referrals
// - Account status: role, expiry, referrals, points, last payment
// - Free tiers: daily 2 odds snapshots; strategy tips
// - Admin tools: approve, approvevvip, force_role, audit
// - Threaded Telegram job loop via Redis

import Redis from "ioredis";
import fetch from "node-fetch";

// ---------- Env ----------
const {
  REDIS_URL,
  TELEGRAM_TOKEN,
  API_FOOTBALL_KEY,
  API_FOOTBALL_BASE,
  TELEGRAM_SAFE_CHUNK,
  ADMIN_TELEGRAM_ID,
  SERVICE_NAME,
  BOT_USERNAME,

  // Local UI base (used in links for help docs or future web dashboards)
  APP_BASE_URL,

  // M-Pesa (Daraja)
  MPESA_CONSUMER_KEY,
  MPESA_CONSUMER_SECRET,
  MPESA_SHORTCODE,
  MPESA_PASSKEY,
  MPESA_ENV,              // sandbox | production
  MPESA_CALLBACK_URL,     // must be public: https(s)://.../webhooks/mpesa

  // PayPal
  PAYPAL_CLIENT_ID,
  PAYPAL_CLIENT_SECRET,
  PAYPAL_ENV,             // sandbox | live
  PAYPAL_WEBHOOK_ID,      // optional: for signature verification
  PAYPAL_SUCCESS_URL,     // https://.../payments/paypal/success (not used in bot, but kept for web)
  PAYPAL_CANCEL_URL,      // https://.../payments/paypal/cancel

  // Binance (manual verification)
  BINANCE_WALLET_ADDRESS,
  BINANCE_MEMO_TAG,

  // Payment details (manual references for non-API flows)
  MPESA_PAYBILL,          // e.g., "123456"
  MPESA_TILL,             // optional: "123456"
  MPESA_ACCOUNT,          // e.g., "BETRIX"
  BTC_ADDRESS,            // e.g., "bc1qexample..."
  SWIFT_BANK_NAME,        // e.g., "Example Bank"
  SWIFT_ACCOUNT_NAME,     // e.g., "BETRIX LTD"
  SWIFT_IBAN,             // e.g., "XX00 XXXX XXXX XXXX ..."
  SWIFT_SWIFT,            // e.g., "ABCD1234"
} = process.env;

const REQUIRED_ENVS = {
  REDIS_URL, TELEGRAM_TOKEN, API_FOOTBALL_KEY, API_FOOTBALL_BASE
};
for (const [k, v] of Object.entries(REQUIRED_ENVS)) {
  if (!v) {
    console.error(`[FATAL] Missing env: ${k}`);
    process.exit(1);
  }
}

const TZ = "Africa/Nairobi";
const SAFE_CHUNK = Math.max(500, Number(TELEGRAM_SAFE_CHUNK || 3000));
const HEADERS = { "x-apisports-key": API_FOOTBALL_KEY };

const PAGE_SIZE = 5;
const MAX_TABLE_ROWS = 20;
const MAX_AGG_ROWS = 30;
const FREE_ODDS_DAILY_LIMIT = 2;

// Pricing and roles
const SIGNUP_FEE_KES = 150;
const SIGNUP_FEE_USD = 1;

const VVIP_DAILY_KES = 200;
const VVIP_WEEKLY_KES = 800;
const VVIP_MONTHLY_KES = 2500;

const VVIP_DAILY_USD = 2;
const VVIP_WEEKLY_USD = 6;
const VVIP_MONTHLY_USD = 20;

const ROLE_FREE = "free";
const ROLE_MEMBER = "member";
const ROLE_VVIP = "vvip";

// VVIP durations (ms)
const DAY_MS = 24 * 60 * 60 * 1000;
const WEEK_MS = 7 * DAY_MS;
const MONTH_MS = 30 * DAY_MS;

// League mapping
const LEAGUES = {
  epl: 39, premierleague: 39, england: 39,
  laliga: 140, spain: 140,
  seriea: 135, italy: 135,
  bundesliga: 78, germany: 78,
  ligue1: 61, france: 61,
  ucl: 2, championsleague: 2
};
function normLeagueId(token) {
  if (!token) return null;
  const t = String(token).toLowerCase().replace(/\s+/g, "");
  if (/^\d+$/.test(t)) return Number(t);
  return LEAGUES[t] || null;
}

// ---------- Emojis & UI ----------
const ICONS = {
  brand: "üöÄ",
  live: "üî¥",
  today: "üìÖ",
  next: "‚è≠Ô∏è",
  fixtures: "üìú",
  standings: "üìä",
  odds: "üé≤",
  tips: "üß†",
  analysis: "üîç",
  lineups: "üßæ",
  h2h: "‚öîÔ∏è",
  news: "üóûÔ∏è",
  pricing: "üíµ",
  pay: "üí≥",
  status: "üß©",
  support: "üõ†Ô∏è",
  menu: "üß≠",
  vvip: "üíé",
  rules: "üõ°Ô∏è",
  about: "‚ÑπÔ∏è",
  contact: "‚úâÔ∏è",
  refer: "üë•",
  rewards: "üèÜ",
  leaderboard: "ü•á",
  pagePrev: "‚óÄÔ∏è",
  pageNext: "‚ñ∂Ô∏è",
  pageInfo: "üî¢",
  refresh: "üîÑ",
  back: "‚¨ÖÔ∏è",
  signup: "üìù",
  strategy: "üìê",
  free: "üéÅ"
};
const MEMES = [
  "‚ö° Neutral insights only. No hype, just signal.",
  "üß† Smart is calm. Calm is profitable (in time).",
  "üéØ Process over luck. Every day.",
  "üõ∞Ô∏è Futuristic menu, grounded ethics."
];
const STRATEGY_TIPS = [
  "Bankroll discipline: stake small, consistent amounts; never chase losses.",
  "Specialize: focus on one league/market to reduce noise and improve context.",
  "Use multiple lenses: standings + form + neutral odds for a fuller picture.",
  "Time boundaries: set daily limits; this is entertainment, not pressure.",
  "Treat odds as information, not guarantees; avoid overconfidence.",
  "Prefer clarity: if a match feels chaotic, skip it and enjoy the game."
];

// ---------- Redis ----------
const redis = new Redis(REDIS_URL);
redis.on("error", err => console.error("[Redis] error:", err));

// ---------- Utils ----------
const sleep = ms => new Promise(r => setTimeout(r, ms));

function normalizeTextSpaces(text) {
  return String(text).replace(/\u200B|\u200C|\u200D|\u2060|\u00A0/g, "");
}
function parseArgs(text) {
  const cleaned = normalizeTextSpaces(text).trim();
  const parts = cleaned.split(/\s+/);
  const rawCmd = parts[0];
  const cmd = rawCmd.replace(/@[\w_]+$/, "").toLowerCase();
  const args = parts.slice(1);
  return { cmd, args };
}

async function safeFetch(url, options = {}, label = "request", retries = 2, timeoutMs = 15000) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { ...options, signal: controller.signal });
    const text = await res.text();
    clearTimeout(timer);
    if (!res.ok) throw new Error(`[${label}] HTTP ${res.status} ${res.statusText} ${text}`);
    // Some endpoints return no JSON; handle gracefully
    try {
      return JSON.parse(text);
    } catch {
      return text.length ? JSON.parse(text) : {};
    }
  } catch (err) {
    clearTimeout(timer);
    if (retries > 0) {
      console.warn(`[Retry] ${label}: ${err.message}`);
      await sleep(600);
      return safeFetch(url, options, label, retries - 1, timeoutMs);
    }
    throw err;
  }
}

function escapeHtml(s) {
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

function chunkText(text, chunkSize = SAFE_CHUNK) {
  if (!text) return [""];
  const chunks = [];
  let remaining = String(text);

  while (remaining.length > chunkSize) {
    let idx = remaining.lastIndexOf("\n", chunkSize);
    if (idx === -1 || idx < chunkSize * 0.6) {
      idx = remaining.lastIndexOf(" ", chunkSize);
      if (idx === -1 || idx < chunkSize * 0.6) idx = chunkSize;
    }
    chunks.push(remaining.slice(0, idx));
    remaining = remaining.slice(idx).trimStart();
  }
  if (remaining.length) chunks.push(remaining);
  return chunks;
}

async function sendTelegram(chatId, text, opts = {}) {
  const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
  const chunks = chunkText(text);
  for (let i = 0; i < chunks.length; i++) {
    const suffix = chunks.length > 1 ? `\n\nPage ${i + 1}/${chunks.length}` : "";
    const body = {
      chat_id: chatId,
      text: chunks[i] + suffix,
      parse_mode: "HTML",
      disable_web_page_preview: true,
      ...opts
    };
    await safeFetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    }, "sendMessage");
  }
}

async function editMessageText(chatId, messageId, text, replyMarkup = undefined) {
  const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/editMessageText`;
  const body = {
    chat_id: chatId,
    message_id: messageId,
    text,
    parse_mode: "HTML",
    disable_web_page_preview: true,
    ...(replyMarkup ? { reply_markup: replyMarkup } : {})
  };
  await safeFetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  }, "editMessageText");
}

async function answerCallbackQuery(callbackQueryId, text = "") {
  const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/answerCallbackQuery`;
  const body = { callback_query_id: callbackQueryId, text, show_alert: false };
  await safeFetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  }, "answerCallbackQuery");
}

function fmtList(title, rows) {
  const list = Array.isArray(rows) ? rows : [];
  if (!list.length) return `<b>${escapeHtml(title)}:</b> none`;
  return `<b>${escapeHtml(title)}:</b>\n` + list.map(r => `- ${escapeHtml(r)}`).join("\n");
}

function fmtDate(iso) {
  try {
    const d = new Date(iso);
    return `${d.toLocaleDateString()} ${d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;
  } catch {
    return iso;
  }
}

function defaultSeason() {
  const d = new Date();
  const m = d.getUTCMonth() + 1;
  const y = d.getUTCFullYear();
  return m >= 7 ? y : y - 1;
}

function pickOne(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function usage(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function friendlyError(err, prefix) {
  const msg = typeof err === "string" ? err : (err?.message || "Unknown error");
  return `${prefix} temporarily unavailable. Please try again shortly.\nDetails: ${escapeHtml(msg)}`;
}

// ---------- Cache helpers ----------
async function cacheGet(key) {
  try {
    const raw = await redis.get(key);
    return raw ? JSON.parse(raw) : null;
  } catch { return null; }
}
async function cacheSet(key, value, ttlSec) {
  try {
    await redis.set(key, JSON.stringify(value), "EX", Math.max(10, ttlSec));
  } catch { /* ignore */ }
}

// ---------- Users, referrals, roles ----------
async function getUser(userId) {
  const key = `user:${userId}`;
  const raw = await redis.get(key);
  return raw ? JSON.parse(raw) : null;
}
async function putUser(userId, data) {
  const key = `user:${userId}`;
  const current = await getUser(userId) || {};
  const next = { ...current, ...data };
  await redis.set(key, JSON.stringify(next));
  return next;
}
function isPaid(user) { return Boolean(user?.paid_at); }
function isVVIP(user) {
  if (user?.role !== ROLE_VVIP) return false;
  if (!user?.vvip_expires_at) return true;
  return Date.now() < Number(user.vvip_expires_at);
}

function makeReferralCode(userId) {
  const base = Buffer.from(String(userId)).toString("base64").replace(/=+/g, "");
  const rand = Math.random().toString(36).slice(2, 6);
  return `${base}-${rand}`;
}
async function getOrCreateReferral(userId) {
  let user = await getUser(userId);
  if (!user?.referral_code) {
    const code = makeReferralCode(userId);
    user = await putUser(userId, { referral_code: code, referrals_count: 0, rewards_points: 0 });
  }
  return user.referral_code;
}
async function applyReferral(code, newUserId) {
  const base = (code || "").split("-")[0];
  let referrerId;
  try {
    referrerId = Buffer.from(base, "base64").toString("utf8");
  } catch { return null; }
  if (!/^\d+$/.test(referrerId)) return null;

  if (String(referrerId) !== String(newUserId)) {
    const refUser = await getUser(referrerId) || {};
    const count = Number(refUser.referrals_count || 0) + 1;
    const points = Number(refUser.rewards_points || 0) + 10;
    await putUser(referrerId, { referrals_count: count, rewards_points: points });
    await redis.zincrby("leaderboard:referrals", 1, String(referrerId));
  }
  await putUser(newUserId, { referred_by: referrerId, referral_used: code });
  return referrerId;
}

// ---------- Gates ----------
function gateFreeCommands(cmd) {
  const free = new Set([
    "/start", "/menu", "/help", "/status", "/pricing", "/about", "/rules",
    "/contact", "/support", "/news", "/tips", "/refer", "/rewards", "/leaderboard",
    "/live", "/today", "/next", "/fixtures", "/standings",
    "/signup", "/pay",
    "/free_odds", "/strategy",
    "/fixed"
  ]);
  return free.has(cmd);
}
function gateMemberCommands(cmd) {
  const member = new Set([
    "/odds", "/analysis", "/form", "/headtohead", "/lineups", "/injuries", "/markets", "/schedule"
  ]);
  return member.has(cmd);
}
function gateVVIPCommands(cmd) {
  const vvip = new Set([
    "/vvip", "/vvip_today", "/vvip_matches", "/vvip_digest"
  ]);
  return vvip.has(cmd);
}

// ---------- API-Football ----------
const ApiFootball = {
  async live() {
    const key = `fixtures:live:${TZ}`;
    const hit = await cacheGet(key);
    if (hit) return hit;
    const url = `${API_FOOTBALL_BASE}/fixtures?live=all&timezone=${encodeURIComponent(TZ)}`;
    const data = await safeFetch(url, { headers: HEADERS }, "ApiFootball.live");
    await cacheSet(key, data, 30);
    return data;
  },

  async fixtures({ league, season }) {
    const key = `fixtures:league:${league}:season:${season}:${TZ}`;
    const hit = await cacheGet(key);
    if (hit) return hit;
    const url = `${API_FOOTBALL_BASE}/fixtures?league=${encodeURIComponent(league)}&season=${encodeURIComponent(season)}&timezone=${encodeURIComponent(TZ)}`;
    const data = await safeFetch(url, { headers: HEADERS }, "ApiFootball.fixtures");
    await cacheSet(key, data, 300);
    return data;
  },

  async fixturesByDate(date, { league } = {}) {
    const key = `fixtures:date:${date}:league:${league || "all"}:${TZ}`;
    const hit = await cacheGet(key);
    if (hit) return hit;
    const url = `${API_FOOTBALL_BASE}/fixtures?date=${encodeURIComponent(date)}${league ? `&league=${encodeURIComponent(league)}` : ""}&timezone=${encodeURIComponent(TZ)}`;
    const data = await safeFetch(url, { headers: HEADERS }, "ApiFootball.fixturesByDate");
    await cacheSet(key, data, 300);
    return data;
  },

  async nextFixtures({ count = 10, league }) {
    const key = `fixtures:next:${count}:league:${league || "all"}:${TZ}`;
    const hit = await cacheGet(key);
    if (hit) return hit;
    const url = `${API_FOOTBALL_BASE}/fixtures?next=${Number(count)}${league ? `&league=${encodeURIComponent(league)}` : ""}&timezone=${encodeURIComponent(TZ)}`;
    const data = await safeFetch(url, { headers: HEADERS }, "ApiFootball.fixturesNext");
    await cacheSet(key, data, 300);
    return data;
  },

  async standings({ league, season }) {
    const key = `standings:${league}:${season}`;
    const hit = await cacheGet(key);
    if (hit) return hit;
    const url = `${API_FOOTBALL_BASE}/standings?league=${encodeURIComponent(league)}&season=${encodeURIComponent(season)}`;
    const data = await safeFetch(url, { headers: HEADERS }, "ApiFootball.standings");
    await cacheSet(key, data, 21600);
    return data;
  },

  async odds({ fixture }) {
    const key = `odds:fixture:${fixture}:${TZ}`;
    const hit = await cacheGet(key);
    if (hit) return hit;
    const url = `${API_FOOTBALL_BASE}/odds?fixture=${encodeURIComponent(fixture)}&timezone=${encodeURIComponent(TZ)}`;
    const data = await safeFetch(url, { headers: HEADERS }, "ApiFootball.odds");
    await cacheSet(key, data, 120);
    return data;
  },

  async oddsByDate(date, { league } = {}) {
    const key = `odds:date:${date}:league:${league || "all"}:${TZ}`;
    const hit = await cacheGet(key);
    if (hit) return hit;
    const url = `${API_FOOTBALL_BASE}/odds?date=${encodeURIComponent(date)}${league ? `&league=${encodeURIComponent(league)}` : ""}&timezone=${encodeURIComponent(TZ)}`;
    const data = await safeFetch(url, { headers: HEADERS }, "ApiFootball.oddsByDate");
    await cacheSet(key, data, 120);
    return data;
  }
};

// ---------- Format helpers ----------
function fmtFixtureItem(f) {
  const date = escapeHtml(fmtDate(f?.fixture?.date));
  const home = escapeHtml(f?.teams?.home?.name ?? "Home");
  const away = escapeHtml(f?.teams?.away?.name ?? "Away");
  const fid = escapeHtml(f?.fixture?.id ?? "N/A");
  return `${date} ‚Äî ${home} vs ${away} (ID: ${fid})`;
}

function listLive(title, arr, page, totalPages) {
  const start = page * PAGE_SIZE;
  const slice = (arr ?? []).slice(start, start + PAGE_SIZE);
  const items = slice.map(f => {
    const home = escapeHtml(f?.teams?.home?.name ?? "Home");
    const away = escapeHtml(f?.teams?.away?.name ?? "Away");
    const hs = escapeHtml(f?.goals?.home ?? 0);
    const as = escapeHtml(f?.goals?.away ?? 0);
    const status = escapeHtml(f?.fixture?.status?.short ?? "LIVE");
    const fid = escapeHtml(f?.fixture?.id ?? "N/A");
    return `${home} vs ${away} ‚Äî ${hs}:${as} (${status}) (ID: ${fid})`;
  });
  const header = `${ICONS.live} ${title} ${ICONS.pageInfo} Page ${page + 1}/${totalPages}`;
  return fmtList(header, items);
}

function listFixtures(title, arr, page, totalPages) {
  const start = page * PAGE_SIZE;
  const slice = (arr ?? []).slice(start, start + PAGE_SIZE);
  const items = slice.map(fmtFixtureItem);
  const header = `${ICONS.fixtures} ${title} ${ICONS.pageInfo} Page ${page + 1}/${totalPages}`;
  return fmtList(header, items);
}

function listStandings(title, arr) {
  const rows = (arr ?? []).slice(0, MAX_TABLE_ROWS).map(r =>
    `${escapeHtml(r?.rank)}. ${escapeHtml(r?.team?.name)} ‚Äî ${escapeHtml(r?.points)} pts (W${escapeHtml(r?.all?.win)}-D${escapeHtml(r?.all?.draw)}-L${escapeHtml(r?.all?.lose)})`
  );
  return fmtList(`${ICONS.standings} ${title}`, rows);
}

// ---------- Pagination state ----------
async function setPage(chatId, context, page) {
  const key = `page:${chatId}:${context}`;
  await redis.set(key, String(page), "EX", 600);
}
async function getPage(chatId, context) {
  const key = `page:${chatId}:${context}`;
  const raw = await redis.get(key);
  return raw ? Number(raw) : 0;
}
async function setList(chatId, context, list) {
  const key = `list:${chatId}:${context}`;
  await redis.set(key, JSON.stringify(list || []), "EX", 600);
}
async function getList(chatId, context) {
  const key = `list:${chatId}:${context}`;
  const raw = await redis.get(key);
  return raw ? JSON.parse(raw) : [];
}

// ---------- Inline keyboards ----------
function kbForFixtures(fixtures, page, totalPages, contextTag = "FX") {
  const slice = (fixtures ?? []).slice(page * PAGE_SIZE, page * PAGE_SIZE + PAGE_SIZE);
  const rows = slice.map(f => {
    const fid = String(f?.fixture?.id ?? "");
    return [
      { text: "üîç Analyze", callback_data: `ANALYZE:${fid}` },
      { text: "üé≤ Odds",    callback_data: `ODDS:${fid}` },
      { text: "üßæ Lineups", callback_data: `LINEUPS:${fid}` }
    ];
  });

  const nav = [];
  if (page > 0) nav.push({ text: `${ICONS.pagePrev} Prev`, callback_data: `PAGENAV:${contextTag}:${page - 1}` });
  if (page + 1 < totalPages) nav.push({ text: `${ICONS.pageNext} Next`, callback_data: `PAGENAV:${contextTag}:${page + 1}` });
  if (nav.length) rows.push(nav);

  rows.push([{ text: `${ICONS.refresh} Refresh`, callback_data: `REFRESH:${contextTag}:${page}` }]);
  rows.push([{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }]);

  return { inline_keyboard: rows };
}

function universalNav(page, totalPages, contextTag) {
  const navRow = [
    ...(page > 0 ? [{ text: `${ICONS.pagePrev} Prev`, callback_data: `PAGENAV:${contextTag}:${page - 1}` }] : []),
    ...(page + 1 < totalPages ? [{ text: `${ICONS.pageNext} Next`, callback_data: `PAGENAV:${contextTag}:${page + 1}` }] : [])
  ];
  const rows = [];
  if (navRow.length) rows.push(navRow);
  rows.push([{ text: `${ICONS.refresh} Refresh`, callback_data: `REFRESH:${contextTag}:${page}` }]);
  rows.push([{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }]);
  return { inline_keyboard: rows };
}

// ---------- Payment integration helpers ----------
// M-Pesa Daraja
const MPESA_API = (MPESA_ENV === "production") ? "https://api.safaricom.co.ke" : "https://sandbox.safaricom.co.ke";
async function mpesaToken() {
  const creds = Buffer.from(`${MPESA_CONSUMER_KEY}:${MPESA_CONSUMER_SECRET}`).toString("base64");
  const res = await fetch(`${MPESA_API}/oauth/v1/generate?grant_type=client_credentials`, {
    headers: { Authorization: `Basic ${creds}` }
  });
  if (!res.ok) throw new Error(`mpesaToken status ${res.status}`);
  return res.json();
}
function mpesaTimestamp() {
  const d = new Date();
  const pad = (n) => n.toString().padStart(2, '0');
  return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
function mpesaPassword(shortcode, passkey, timestamp) {
  return Buffer.from(`${shortcode}${passkey}${timestamp}`).toString("base64");
}
async function mpesaStkPush({ amount, phoneNumber, accountReference = "BETRIX", transactionDesc = "BETRIX VVIP Payment" }) {
  const { access_token } = await mpesaToken();
  const timestamp = mpesaTimestamp();
  const password = mpesaPassword(MPESA_SHORTCODE, MPESA_PASSKEY, timestamp);

  const payload = {
    BusinessShortCode: Number(MPESA_SHORTCODE),
    Password: password,
    Timestamp: timestamp,
    TransactionType: "CustomerPayBillOnline",
    Amount: Number(amount),
    PartyA: phoneNumber,
    PartyB: Number(MPESA_SHORTCODE),
    PhoneNumber: phoneNumber,
    CallBackURL: MPESA_CALLBACK_URL,
    AccountReference: accountReference,
    TransactionDesc: transactionDesc
  };

  const res = await fetch(`${MPESA_API}/mpesa/stkpush/v1/processrequest`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${access_token}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(`STK push failed: ${res.status} ${JSON.stringify(data)}`);
  return data;
}

// PayPal REST
const PAYPAL_API = (PAYPAL_ENV === "live") ? "https://api-m.paypal.com" : "https://api-m.sandbox.paypal.com";
async function paypalAccessToken() {
  const creds = Buffer.from(`${PAYPAL_CLIENT_ID}:${PAYPAL_CLIENT_SECRET}`).toString("base64");
  const res = await fetch(`${PAYPAL_API}/v1/oauth2/token`, {
    method: "POST",
    headers: { Authorization: `Basic ${creds}`, "Content-Type": "application/x-www-form-urlencoded" },
    body: "grant_type=client_credentials",
  });
  if (!res.ok) throw new Error(`paypalAccessToken ${res.status}`);
  return res.json();
}
async function paypalCreateOrder({ amount, currency = "USD", description = "BETRIX Payment" }) {
  const { access_token } = await paypalAccessToken();
  const body = {
    intent: "CAPTURE",
    purchase_units: [{ amount: { currency_code: currency, value: String(amount) }, description }],
    application_context: {
      brand_name: "BETRIX",
      landing_page: "LOGIN",
      user_action: "PAY_NOW",
      return_url: PAYPAL_SUCCESS_URL || "https://example.com/paypal/success",
      cancel_url: PAYPAL_CANCEL_URL || "https://example.com/paypal/cancel",
    },
  };
  const res = await fetch(`${PAYPAL_API}/v2/checkout/orders`, {
    method: "POST",
    headers: { Authorization: `Bearer ${access_token}`, "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(`paypalCreateOrder ${res.status}: ${JSON.stringify(data)}`);
  return data;
}
async function paypalCaptureOrder(orderId) {
  const { access_token } = await paypalAccessToken();
  const res = await fetch(`${PAYPAL_API}/v2/checkout/orders/${orderId}/capture`, {
    method: "POST",
    headers: { Authorization: `Bearer ${access_token}`, "Content-Type": "application/json" },
  });
  const data = await res.json();
  if (!res.ok) throw new Error(`paypalCaptureOrder ${res.status}: ${JSON.stringify(data)}`);
  return data;
}
async function paypalCreateSubscription({ planId }) {
  const { access_token } = await paypalAccessToken();
  const body = {
    plan_id: planId,
    application_context: {
      brand_name: "BETRIX",
      shipping_preference: "NO_SHIPPING",
      user_action: "SUBSCRIBE_NOW",
      return_url: PAYPAL_SUCCESS_URL || "https://example.com/paypal/success",
      cancel_url: PAYPAL_CANCEL_URL || "https://example.com/paypal/cancel",
    },
  };
  const res = await fetch(`${PAYPAL_API}/v1/billing/subscriptions`, {
    method: "POST",
    headers: { Authorization: `Bearer ${access_token}`, "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(`paypalCreateSubscription ${res.status}: ${JSON.stringify(data)}`);
  return data;
}
function verifyPaypalWebhookHeaders(h) {
  const reqHeaders = [
    h["paypal-transmission-id"],
    h["paypal-transmission-time"],
    h["paypal-transmission-sig"],
    h["paypal-cert-url"],
    h["paypal-auth-algo"],
    PAYPAL_WEBHOOK_ID,
  ];
  return reqHeaders.every(Boolean);
}

// ---------- Payment menus ----------
async function showSignup(chatId) {
  const text =
    `${ICONS.signup} <b>Signup</b>\n` +
    `Choose your path:\n` +
    `- Member: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}\n` +
    `- VVIP Daily: KES ${VVIP_DAILY_KES} / USD ${VVIP_DAILY_USD}\n` +
    `- VVIP Weekly: KES ${VVIP_WEEKLY_KES} / USD ${VVIP_WEEKLY_USD}\n` +
    `- VVIP Monthly: KES ${VVIP_MONTHLY_KES} / USD ${VVIP_MONTHLY_USD}\n\n` +
    `Next: select a tier below, then choose your payment method.`;

  const kb = {
    inline_keyboard: [
      [{ text: `Member ‚Äî KES ${SIGNUP_FEE_KES}`, callback_data: "PAY:member:kes" },
       { text: `Member ‚Äî USD ${SIGNUP_FEE_USD}`, callback_data: "PAY:member:usd" }],
      [{ text: `VVIP Daily ‚Äî KES ${VVIP_DAILY_KES}`, callback_data: "PAY:vvip:daily:kes" },
       { text: `VVIP Daily ‚Äî USD ${VVIP_DAILY_USD}`, callback_data: "PAY:vvip:daily:usd" }],
      [{ text: `VVIP Weekly ‚Äî KES ${VVIP_WEEKLY_KES}`, callback_data: "PAY:vvip:weekly:kes" },
       { text: `VVIP Weekly ‚Äî USD ${VVIP_WEEKLY_USD}`, callback_data: "PAY:vvip:weekly:usd" }],
      [{ text: `VVIP Monthly ‚Äî KES ${VVIP_MONTHLY_KES}`, callback_data: "PAY:vvip:monthly:kes" },
       { text: `VVIP Monthly ‚Äî USD ${VVIP_MONTHLY_USD}`, callback_data: "PAY:vvip:monthly:usd" }],
      [{ text: "M-Pesa (STK Push)", callback_data: "PAY_METHOD:mpesa" },
       { text: "PayPal (Card)", callback_data: "PAY_METHOD:paypal" }],
      [{ text: "Binance (Crypto)", callback_data: "PAY_METHOD:binance" }],
      [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }]
    ]
  };
  return sendTelegram(chatId, text, { reply_markup: kb });
}

async function showPaymentOptions(chatId) {
  const text =
    `${ICONS.pay} <b>Payment options</b>\n` +
    `Member signup: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}\n` +
    `VVIP tiers:\n` +
    `- Daily: KES ${VVIP_DAILY_KES} / USD ${VVIP_DAILY_USD}\n` +
    `- Weekly: KES ${VVIP_WEEKLY_KES} / USD ${VVIP_WEEKLY_USD}\n` +
    `- Monthly: KES ${VVIP_MONTHLY_KES} / USD ${VVIP_MONTHLY_USD}\n\n` +
    `Pick a tier, then choose M-Pesa (STK), PayPal (Card), or Binance.\n` +
    `If manual, redeem with /redeem <receipt> [daily|weekly|monthly].`;

  const kb = {
    inline_keyboard: [
      [{ text: `Member ‚Äî KES ${SIGNUP_FEE_KES}`, callback_data: "PAY:member:kes" },
       { text: `Member ‚Äî USD ${SIGNUP_FEE_USD}`, callback_data: "PAY:member:usd" }],
      [{ text: `VVIP Daily ‚Äî KES ${VVIP_DAILY_KES}`, callback_data: "PAY:vvip:daily:kes" },
       { text: `VVIP Daily ‚Äî USD ${VVIP_DAILY_USD}`, callback_data: "PAY:vvip:daily:usd" }],
      [{ text: `VVIP Weekly ‚Äî KES ${VVIP_WEEKLY_KES}`, callback_data: "PAY:vvip:weekly:kes" },
       { text: `VVIP Weekly ‚Äî USD ${VVIP_WEEKLY_USD}`, callback_data: "PAY:vvip:weekly:usd" }],
      [{ text: `VVIP Monthly ‚Äî KES ${VVIP_MONTHLY_KES}`, callback_data: "PAY:vvip:monthly:kes" },
       { text: `VVIP Monthly ‚Äî USD ${VVIP_MONTHLY_USD}`, callback_data: "PAY:vvip:monthly:usd" }],
      [{ text: "M-Pesa (STK Push)", callback_data: "PAY_METHOD:mpesa" },
       { text: "PayPal (Card)", callback_data: "PAY_METHOD:paypal" }],
      [{ text: "Binance (Crypto)", callback_data: "PAY_METHOD:binance" }],
      [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }]
    ]
  };
  return sendTelegram(chatId, text, { reply_markup: kb });
}

async function handlePayMethod(chatId, callbackQueryId, method, userId) {
  await answerCallbackQuery(callbackQueryId, "Payment method selected.");
  if (method === "mpesa") {
    const text =
      `${ICONS.pay} <b>M-Pesa STK Push</b>\n` +
      `Tap to initiate STK Push. Ensure number format 2547XXXXXXXX.\n` +
      `After success, you'll get auto confirmation via webhook.\n\n` +
      `For manual paybill/till:\n` +
      `Paybill: ${escapeHtml(MPESA_PAYBILL || "‚Äî")}${MPESA_TILL ? ` | Till: ${escapeHtml(MPESA_TILL)}` : ""}\n` +
      `Account: ${escapeHtml(MPESA_ACCOUNT || "‚Äî")}\n` +
      `Then: /redeem <M-Pesa code> [daily|weekly|monthly]`;
    const kb = {
      inline_keyboard: [
        [{ text: "‚ñ∂Ô∏è Initiate STK Push", callback_data: "MPESA_STK:open" }],
        [{ text: `üß≠ Back to signup`, callback_data: "SHOW_SIGNUP" }],
        [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }],
      ]
    };
    return sendTelegram(chatId, text, { reply_markup: kb });
  }
  if (method === "paypal") {
    const text =
      `${ICONS.pay} <b>PayPal (Cards)</b>\n` +
      `Choose one-time order or recurring subscription for VVIP tiers.\n` +
      `After approval, status updates via webhook.\n\n` +
      `One-time: /paypal_order <amount> [USD]\n` +
      `Subscription: /paypal_sub <planId>`;
    const kb = {
      inline_keyboard: [
        [{ text: "üßæ Create Order (One-time)", callback_data: "PAYPAL_ORDER:open" }],
        [{ text: "üîÅ Create Subscription", callback_data: "PAYPAL_SUB:open" }],
        [{ text: `üß≠ Back to signup`, callback_data: "SHOW_SIGNUP" }],
        [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }],
      ]
    };
    return sendTelegram(chatId, text, { reply_markup: kb });
  }
  if (method === "binance") {
    const memo = BINANCE_MEMO_TAG ? `\nMEMO/Tag: <b>${escapeHtml(BINANCE_MEMO_TAG)}</b>` : "";
    const text =
      `${ICONS.pay} <b>Binance (Crypto)</b>\n` +
      `Wallet: <code>${escapeHtml(BINANCE_WALLET_ADDRESS || "‚Äî")}</code>${memo}\n` +
      `Use correct network (e.g., TRC20 for USDT, BEP20 for BNB).\n\n` +
      `After sending, reply:\n` +
      `/redeem <tx-hash> [daily|weekly|monthly]\n` +
      `Manual verification for now.`;
    const kb = {
      inline_keyboard: [
        [{ text: `üß≠ Back to signup`, callback_data: "SHOW_SIGNUP" }],
        [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }],
      ]
    };
    return sendTelegram(chatId, text, { reply_markup: kb });
  }
}

// Initiate flows triggered via buttons or commands
async function initiateMpesaStk(chatId, amount, phoneNumber, accountReference, desc, userId) {
  if (!MPESA_CONSUMER_KEY || !MPESA_CONSUMER_SECRET || !MPESA_SHORTCODE || !MPESA_PASSKEY || !MPESA_ENV || !MPESA_CALLBACK_URL) {
    return sendTelegram(chatId, friendlyError("M-Pesa env incomplete", "M-Pesa STK"));
  }
  try {
    const resp = await mpesaStkPush({
      amount,
      phoneNumber,
      accountReference: accountReference || "BETRIX",
      transactionDesc: desc || "BETRIX VVIP Payment",
    });
    const text =
      `‚úÖ <b>M-Pesa STK Push Initiated</b>\n` +
      `Amount: ${escapeHtml(String(amount))}\n` +
      `Phone: ${escapeHtml(String(phoneNumber))}\n` +
      `CheckoutRequestID: ${escapeHtml(resp.CheckoutRequestID || "N/A")}\n` +
      `You should receive an M-Pesa prompt shortly.\n\n` +
      `We‚Äôll confirm via webhook once processed.`;
    const kb = { inline_keyboard: [[{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }]] };
    await sendTelegram(chatId, text, { reply_markup: kb });
  } catch (e) {
    await sendTelegram(chatId, friendlyError(e, "M-Pesa STK Push"));
  }
}

async function initiatePaypalOrder(chatId, amount, currency = "USD", description = "BETRIX Payment") {
  if (!PAYPAL_CLIENT_ID || !PAYPAL_CLIENT_SECRET || !PAYPAL_ENV) {
    return sendTelegram(chatId, friendlyError("PayPal env incomplete", "PayPal Order"));
  }
  try {
    const order = await paypalCreateOrder({ amount, currency, description });
    const approveLink = (order.links || []).find(l => l.rel === "approve")?.href || "N/A";
    const text =
      `üßæ <b>PayPal Order Created</b>\n` +
      `Amount: ${escapeHtml(String(amount))} ${escapeHtml(currency)}\n` +
      `Approve: ${escapeHtml(approveLink)}\n` +
      `After approval, you‚Äôll be redirected to BETRIX.\n` +
      `We‚Äôll confirm via webhook.`;
    const kb = {
      inline_keyboard: [
        [{ text: "üßæ Approve Payment", url: approveLink }],
        [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }],
      ]
    };
    await sendTelegram(chatId, text, { reply_markup: kb });
  } catch (e) {
    await sendTelegram(chatId, friendlyError(e, "PayPal Order"));
  }
}

async function initiatePaypalSubscription(chatId, planId) {
  if (!PAYPAL_CLIENT_ID || !PAYPAL_CLIENT_SECRET || !PAYPAL_ENV) {
    return sendTelegram(chatId, friendlyError("PayPal env incomplete", "PayPal Subscription"));
  }
  try {
    const sub = await paypalCreateSubscription({ planId });
    const approveLink = (sub.links || []).find(l => l.rel === "approve")?.href || "N/A";
    const text =
      `üîÅ <b>Subscription Created</b>\n` +
      `Plan: ${escapeHtml(planId)}\n` +
      `Approve: ${escapeHtml(approveLink)}\n` +
      `Once active (webhook), your VVIP role will be enabled.`;
    const kb = {
      inline_keyboard: [
        [{ text: "üí≥ Approve Subscription", url: approveLink }],
        [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }],
      ]
    };
    await sendTelegram(chatId, text, { reply_markup: kb });
  } catch (e) {
    await sendTelegram(chatId, friendlyError(e, "PayPal Subscription"));
  }
}

// Manual redemption (until webhooks auto-verify)
async function redeemFlow(chatId, args, fromId) {
  const [code, tier] = args;
  if (!code) {
    return sendTelegram(chatId, usage(`${ICONS.pay} Usage: /redeem <receipt-code> [daily|weekly|monthly]`));
  }
  const now = Date.now();
  await putUser(fromId, { last_payment_ref: code, last_payment_at: now });

  if (!tier) {
    await putUser(fromId, { role: ROLE_MEMBER, paid_at: now });
    return sendTelegram(chatId, `${ICONS.status} Member activated. Welcome! Use /menu to explore member commands.`);
  }

  let delta = MONTH_MS;
  if (tier === "daily") delta = DAY_MS;
  else if (tier === "weekly") delta = WEEK_MS;
  else if (tier === "monthly") delta = MONTH_MS;

  await putUser(fromId, { role: ROLE_VVIP, paid_at: now, vvip_expires_at: now + delta });
  return sendTelegram(chatId, `${ICONS.vvip} VVIP activated (${escapeHtml(tier)}). Expires: ${new Date(now + delta).toLocaleDateString()}`);
}

// ---------- Handlers ----------
const handlers = {
  async start({ chatId }) {
    const meme = pickOne(MEMES);
    const fee = `KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}`;
    const tiers =
      `Daily KES ${VVIP_DAILY_KES} / USD ${VVIP_DAILY_USD} ‚Ä¢ ` +
      `Weekly KES ${VVIP_WEEKLY_KES} / USD ${VVIP_WEEKLY_USD} ‚Ä¢ ` +
      `Monthly KES ${VVIP_MONTHLY_KES} / USD ${VVIP_MONTHLY_USD}`;

    const text =
      `<b>${ICONS.brand} BETRIX</b> ‚Äî your ethical, AI-powered football assistant.\n` +
      `One clean place for fixtures, standings, neutral odds, and curated digests.\n` +
      `No predictions or ‚Äúfixed matches‚Äù ‚Äî just signal.\n\n` +
      `${ICONS.pricing} Member: ${fee}\n` +
      `${ICONS.vvip} VVIP: ${tiers}\n` +
      `${ICONS.pay} Pay via M-Pesa STK, PayPal (Cards), or Binance.\n\n` +
      `Open the Futuristic Menu below to begin.\n\n` +
      `${meme}`;
    const kb = { inline_keyboard: [[{ text: "üß≠ Open menu", callback_data: "SHOW_MENU" }]] };
    return sendTelegram(chatId, text, { reply_markup: kb });
  },

  async menu({ chatId }) {
    const text =
      `<b>${ICONS.menu} Futuristic menu</b>\n` +
      `\n<b>Match data</b>\n` +
      `${ICONS.live} /live ‚Äî Live matches (scores, status, quick actions)\n` +
      `${ICONS.today} /today [league] ‚Äî Today‚Äôs fixtures (paginated)\n` +
      `${ICONS.next} /next [count] [league] ‚Äî Upcoming fixtures\n` +
      `${ICONS.fixtures} /fixtures <league|id> <season?> ‚Äî League fixtures\n` +
      `${ICONS.standings} /standings <league|id> <season?> ‚Äî League table\n` +
      `\n<b>Insights (members)</b>\n` +
      `${ICONS.odds} /odds [fixtureId] ‚Äî Neutral odds (paginated)\n` +
      `${ICONS.analysis} /analysis [league season] ‚Äî Standings-based context\n` +
      `${ICONS.h2h} /headtohead <home> <away> ‚Äî Neutral H2H\n` +
      `${ICONS.lineups} /lineups <fixtureId> ‚Äî Lineups (coming soon)\n` +
      `\n<b>Free perks</b>\n` +
      `${ICONS.free} /free_odds ‚Äî 2 neutral odds snapshots daily\n` +
      `${ICONS.strategy} /strategy ‚Äî Winning discipline (neutral tips)\n` +
      `\n<b>Account & payments</b>\n` +
      `${ICONS.signup} /signup ‚Äî Become Member or go VVIP\n` +
      `${ICONS.pricing} /pricing ‚Äî Transparent tiers\n` +
      `${ICONS.pay} /pay ‚Äî M-Pesa STK / PayPal / Binance\n` +
      `${ICONS.status} /status ‚Äî Role, expiry, referrals, points, last payment\n` +
      `${ICONS.refer} /refer ‚Äî Referral link\n` +
      `${ICONS.rewards} /rewards ‚Äî Rewards status\n` +
      `${ICONS.leaderboard} /leaderboard ‚Äî Top referrers\n` +
      `\n<b>Trust & info</b>\n` +
      `${ICONS.rules} /rules ‚Äî Ethical guardrails\n` +
      `${ICONS.about} /about ‚Äî About BETRIX\n` +
      `${ICONS.contact} /contact ‚Äî Contact & support\n\n` +
      `Note: ‚ÄúFixed matches‚Äù are refused. Use /fixed for details.`;
    return sendTelegram(chatId, text);
  },

  async help({ chatId }) {
    const text =
      `<b>${ICONS.menu} Help</b>\n` +
      `Use ${ICONS.pagePrev} Prev / ${ICONS.pageNext} Next to navigate, ${ICONS.refresh} Refresh for latest data, and üß≠ Back to menu everywhere.\n` +
      `League shortcuts: <i>epl</i>, <i>laliga</i>, <i>seriea</i>, <i>bundesliga</i>, <i>ligue1</i>, <i>ucl</i> or numeric IDs.\n` +
      `Members unlock neutral odds and analysis. VVIP gets curated digests.`;
    return sendTelegram(chatId, text);
  },

  async about({ chatId }) {
    return sendTelegram(chatId,
      `${ICONS.about} <b>About BETRIX</b>\n` +
      `Neutral football context with ethical guardrails. No predictions or guarantees, no ‚Äúfixed matches‚Äù.`);
  },

  async rules({ chatId }) {
    return sendTelegram(chatId,
      `${ICONS.rules} <b>Rules & Ethics</b>\n` +
      `- Respectful use\n` +
      `- Neutral information only\n` +
      `- No ‚Äúfixed matches‚Äù\n` +
      `- Avoid financial harm`);
  },

  async contact({ chatId }) {
    return sendTelegram(chatId,
      `${ICONS.contact} <b>Contact</b>\n` +
      `Use /support for assistance. Admin approval requires manual review if enabled.`);
  },

  async support({ chatId }) {
    return sendTelegram(chatId,
      `${ICONS.support} <b>Support</b>\n` +
      `- /menu for commands\n` +
      `- /signup to choose tiers\n` +
      `- /pay to complete payment\n` +
      `- /status to check role, expiry, referrals, points`);
  },

  async pricing({ chatId }) {
    const text =
      `${ICONS.pricing} <b>Pricing</b>\n` +
      `Member (signup): KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}\n` +
      `VVIP tiers:\n` +
      `- Daily: KES ${VVIP_DAILY_KES} / USD ${VVIP_DAILY_USD}\n` +
      `- Weekly: KES ${VVIP_WEEKLY_KES} / USD ${VVIP_WEEKLY_USD}\n` +
      `- Monthly: KES ${VVIP_MONTHLY_KES} / USD ${VVIP_MONTHLY_USD}\n\n` +
      `Access levels:\n` +
      `- Free: schedules, standings, info + 2 free odds daily\n` +
      `- Member: neutral odds, analysis, form, H2H, lineups\n` +
      `- VVIP: curated digest and personalized dashboards (neutral only)`;
    return sendTelegram(chatId, text);
  },

  async signup({ chatId }) { return showSignup(chatId); },
  async pay({ chatId }) { return showPaymentOptions(chatId); },

  async status({ chatId, user }) {
    const role = user?.role || ROLE_FREE;
    const paid = isPaid(user) ? `Yes (since ${new Date(user.paid_at).toLocaleDateString()})` : "No";
    const vvipExp = user?.vvip_expires_at ? new Date(user.vvip_expires_at).toLocaleDateString() : "N/A";
    const lastPayment = user?.last_payment_ref ? `Ref: ${escapeHtml(user.last_payment_ref)} (${new Date(user.last_payment_at).toLocaleDateString()})` : "None";
    const freeOddsUsed = Number(user?.free_odds_count || 0);
    const text =
      `${ICONS.status} <b>Account status</b>\n` +
      `- Role: ${escapeHtml(role)}\n` +
      `- Paid member: ${escapeHtml(paid)}\n` +
      `- VVIP active: ${isVVIP(user) ? "Yes" : "No"}\n` +
      `- VVIP expires: ${escapeHtml(vvipExp)}\n` +
      `- Free odds used today: ${escapeHtml(String(freeOddsUsed))}/${FREE_ODDS_DAILY_LIMIT}\n` +
      `- Referrals: ${escapeHtml(String(user?.referrals_count || 0))}\n` +
      `- Rewards points: ${escapeHtml(String(user?.rewards_points || 0))}\n` +
      `- Last payment: ${lastPayment}\n\n` +
      `Use /pricing, /signup and /pay to upgrade.`;
    return sendTelegram(chatId, text);
  },

  async refer({ chatId, user, fromId }) {
    const code = await getOrCreateReferral(fromId);
    const bot = escapeHtml(BOT_USERNAME || "BETRIXXXXX_bot");
    const link = `https://t.me/${bot}?start=${escapeHtml(code)}`;
    const text =
      `${ICONS.refer} <b>Your referral link</b>\n` +
      `Share: ${link}\n\n` +
      `Rewards:\n` +
      `- +10 points per activated referral\n` +
      `- Points can be redeemed later for perks (e.g., VVIP discounts)`;
    return sendTelegram(chatId, text);
  },

  async rewards({ chatId, user }) {
    const text =
      `${ICONS.rewards} <b>Your rewards</b>\n` +
      `Referrals: ${escapeHtml(String(user?.referrals_count || 0))}\n` +
      `Points: ${escapeHtml(String(user?.rewards_points || 0))}\n\n` +
      `Redeem: Coming soon (apply points towards VVIP tiers).`;
    return sendTelegram(chatId, text);
  },

  async leaderboard({ chatId, fromId }) {
    const entries = await redis.zrevrange("leaderboard:referrals", 0, 9, "WITHSCORES").catch(() => []);
    const rows = [];
    let yourRankLine = null;

    const yourScore = await redis.zscore("leaderboard:referrals", String(fromId)).catch(() => null);
    if (yourScore !== null) {
      const rank = await redis.zrevrank("leaderboard:referrals", String(fromId)).catch(() => null);
      if (rank !== null) yourRankLine = `Your rank: #${rank + 1} with ${yourScore} referrals`;
    }

    for (let i = 0; i < entries.length; i += 2) {
      const userId = entries[i];
      const score = entries[i + 1];
      rows.push(`#${i / 2 + 1} ‚Äî User ${escapeHtml(userId)}: ${escapeHtml(String(score))} referrals`);
    }
    const list = rows.length ? rows : ["No referrals yet. Be the first!"];
    const text = fmtList(`${ICONS.leaderboard} Top referrers`, yourRankLine ? [yourRankLine, ...list] : list);
    return sendTelegram(chatId, text);
  },

  async approve({ chatId, args }) {
    if (!ADMIN_TELEGRAM_ID || String(chatId) !== String(ADMIN_TELEGRAM_ID)) {
      return sendTelegram(chatId, `Admin-only command.`);
    }
    const [userId, role] = args;
    if (!userId) return sendTelegram(chatId, usage(`Usage: /approve <telegramUserId> <role=member|vvip>`));
    const validRole = (role === ROLE_VVIP) ? ROLE_VVIP : ROLE_MEMBER;
    const now = Date.now();
    const patch = validRole === ROLE_MEMBER
      ? { role: ROLE_MEMBER, paid_at: now }
      : { role: ROLE_VVIP, paid_at: now, vvip_expires_at: now + MONTH_MS };
    await putUser(userId, patch);
    return sendTelegram(chatId, `Approved user ${escapeHtml(userId)} as ${escapeHtml(validRole)}.`);
  },

  async approvevvip({ chatId, args }) {
    if (!ADMIN_TELEGRAM_ID || String(chatId) !== String(ADMIN_TELEGRAM_ID)) {
      return sendTelegram(chatId, `Admin-only command.`);
    }
    const [userId, tier] = args;
    if (!userId || !tier) return sendTelegram(chatId, usage(`Usage: /approvevvip <telegramUserId> <daily|weekly|monthly>`));
    const now = Date.now();
    let delta = MONTH_MS;
    if (tier === "daily") delta = DAY_MS;
    else if (tier === "weekly") delta = WEEK_MS;
    else if (tier === "monthly") delta = MONTH_MS;
    await putUser(userId, { role: ROLE_VVIP, paid_at: now, vvip_expires_at: now + delta });
    return sendTelegram(chatId, `VVIP approved ‚Äî user ${escapeHtml(userId)}, tier ${escapeHtml(tier)}, expires ${new Date(now + delta).toLocaleDateString()}.`);
  },

  async force_role({ chatId, args }) {
    if (!ADMIN_TELEGRAM_ID || String(chatId) !== String(ADMIN_TELEGRAM_ID)) {
      return sendTelegram(chatId, `Admin-only command.`);
    }
    const [userId, role] = args;
    if (!userId || !role) return sendTelegram(chatId, usage(`Usage: /force_role <telegramUserId> <free|member|vvip>`));
    const patch = { role };
    await putUser(userId, patch);
    return sendTelegram(chatId, `Forced role for ${escapeHtml(userId)} to ${escapeHtml(role)}.`);
  },

  async audit({ chatId, args }) {
    if (!ADMIN_TELEGRAM_ID || String(chatId) !== String(ADMIN_TELEGRAM_ID)) {
      return sendTelegram(chatId, `Admin-only command.`);
    }
    const [userId] = args;
    if (!userId) return sendTelegram(chatId, usage(`Usage: /audit <telegramUserId>`));
    const user = await getUser(userId);
    return sendTelegram(chatId, `<b>Audit</b>\n${escapeHtml(JSON.stringify(user || {}, null, 2))}`);
  },

  async redeem({ chatId, args, fromId }) {
    return redeemFlow(chatId, args, fromId);
  },

  // Data
  async live({ chatId }) {
    const data = await ApiFootball.live().catch(err => ({ error: err }));
    if (data.error) return sendTelegram(chatId, friendlyError(data.error, ICONS.live + " Live"));
    const rows = (data?.response ?? []);
    const totalPages = Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
    const page = 0;
    await setList(chatId, "LIVE", rows);
    await setPage(chatId, "LIVE", page);
    const text = listLive("Live now", rows, page, totalPages);
    const kb = kbForFixtures(rows, page, totalPages, "LIVE");
    return sendTelegram(chatId, text, { reply_markup: kb });
  },

  async today({ chatId, args }) {
    const leagueToken = args[0];
    const league = normLeagueId(leagueToken);
    const todayStr = new Date().toISOString().slice(0, 10);

    const data = await ApiFootball.fixturesByDate(todayStr, { league }).catch(err => ({ error: err }));
    if (data.error) return sendTelegram(chatId, friendlyError(data.error, ICONS.today + " Fixtures"));

    const rows = (data?.response ?? []);
    const totalPages = Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
    const page = 0;

    await setList(chatId, "TODAY", rows);
    await setPage(chatId, "TODAY", page);

    const title = `Today‚Äôs fixtures${league ? ` (league ${league})` : ""}`;
    const text = listFixtures(title, rows, page, totalPages);
    const kb = kbForFixtures(rows, page, totalPages, "TODAY");
    return sendTelegram(chatId, text, { reply_markup: kb });
  },

  async next({ chatId, args }) {
    const count = /^\d+$/.test(args[0]) ? Number(args[0]) : 10;
    const leagueToken = args.find(a => isNaN(Number(a)));
    const league = normLeagueId(leagueToken);

    const data = await ApiFootball.nextFixtures({ count, league }).catch(err => ({ error: err }));
    if (data.error) return sendTelegram(chatId, friendlyError(data.error, ICONS.next + " Fixtures"));

    const rows = (data?.response ?? []);
    const totalPages = Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
    const page = 0;

    await setList(chatId, "NEXT", rows);
    await setPage(chatId, "NEXT", page);

    const title = `Upcoming fixtures${league ? ` (league ${league})` : ""}, count ${count}`;
    const text = listFixtures(title, rows, page, totalPages);
    const kb = kbForFixtures(rows, page, totalPages, "NEXT");
    return sendTelegram(chatId, text, { reply_markup: kb });
  },

  async fixtures({ chatId, args }) {
    const [leagueToken, seasonArg] = args;
    if (!leagueToken) {
      return sendTelegram(chatId, usage(`${ICONS.fixtures} Usage: /fixtures <leagueId|name> <season?>\nExample: /fixtures epl 2024`));
    }
    const league = normLeagueId(leagueToken);
    if (!league) return sendTelegram(chatId, `${ICONS.fixtures} Unknown league: ${escapeHtml(leagueToken)}. Try epl, laliga, seriea, bundesliga, ligue1, ucl or a numeric ID.`);
    const season = seasonArg || defaultSeason();

    const data = await ApiFootball.fixtures({ league, season }).catch(err => ({ error: err }));
    if (data.error) return sendTelegram(chatId, friendlyError(data.error, ICONS.fixtures + " Fixtures"));

    const rows = (data?.response ?? []);
    const totalPages = Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
    const page = 0;

    await setList(chatId, "FIXT", rows);
    await setPage(chatId, "FIXT", page);

    const text = listFixtures(`Fixtures league ${league} season ${season}`, rows, page, totalPages);
    const kb = kbForFixtures(rows, page, totalPages, "FIXT");
    return sendTelegram(chatId, text, { reply_markup: kb });
  },

  async standings({ chatId, args }) {
    const [leagueToken, seasonArg] = args;
    if (!leagueToken) return sendTelegram(chatId, usage(`${ICONS.standings} Usage: /standings <leagueId|name> <season?>\nExample: /standings epl 2024`));
    const league = normLeagueId(leagueToken);
    if (!league) return sendTelegram(chatId, `${ICONS.standings} Unknown league: ${escapeHtml(leagueToken)}. Try epl, laliga, seriea, bundesliga, ligue1, ucl or a numeric ID.`);
    const season = seasonArg || defaultSeason();

    const data = await ApiFootball.standings({ league, season }).catch(err => ({ error: err }));
    if (data.error) return sendTelegram(chatId, friendlyError(data.error, ICONS.standings + " Standings"));

    const table = (data?.response?.[0]?.league?.standings?.[0] ?? []);
    const text = listStandings(`League ${league} season ${season}`, table);
    return sendTelegram(chatId, text);
  },

  // Free perks
  async free_odds({ chatId, user }) {
    const todayKey = `free_odds:${user?.id || "anon"}:${new Date().toISOString().slice(0, 10)}`;
    let count = Number(await redis.get(todayKey) || 0);
    if (count >= FREE_ODDS_DAILY_LIMIT) {
      return sendTelegram(chatId, `${ICONS.free} Free odds limit reached for today (${FREE_ODDS_DAILY_LIMIT}/${FREE_ODDS_DAILY_LIMIT}). Upgrade for unlimited odds via /signup.`);
    }

    const today = new Date().toISOString().slice(0, 10);
    const fx = await ApiFootball.fixturesByDate(today).catch(err => ({ error: err }));
    if (fx.error) return sendTelegram(chatId, friendlyError(fx.error, ICONS.odds + " Free odds"));

    const fixtures = (fx?.response ?? []).slice(0, 10);
    if (!fixtures.length) return sendTelegram(chatId, `${ICONS.free} No fixtures found for today.`);

    const picks = fixtures.slice(0, 2);
    const lines = [];
    for (const f of picks) {
      const fid = f?.fixture?.id;
      const home = escapeHtml(f?.teams?.home?.name || "Home");
      const away = escapeHtml(f?.teams?.away?.name || "Away");
      lines.push(`${home} vs ${away} ‚Äî fixture ${escapeHtml(String(fid))}`);
    }
    const text =
      `${ICONS.free} <b>Free odds snapshots (2/day)</b>\n` +
      lines.map(l => `- ${l}`).join("\n") + `\n\n` +
      `Use /odds <fixtureId> for detailed markets (members).\n` +
      `Tip: ${pickOne(STRATEGY_TIPS)}\n` +
      `Neutral context only ‚Äî no predictions or guarantees.`;
    count += 1;
    await redis.set(todayKey, String(count), "EX", 24 * 60 * 60);
    const uCount = Number(user?.free_odds_count || 0) + 1;
    await putUser(user?.id || chatId, { free_odds_count: uCount });

    return sendTelegram(chatId, text);
  },

  async strategy({ chatId }) {
    const tip = pickOne(STRATEGY_TIPS);
    const text =
      `${ICONS.strategy} <b>Winning discipline (neutral)</b>\n` +
      `- ${escapeHtml(tip)}\n\n` +
      `Pair discipline with context: standings + form + neutral odds.\n` +
      `Neutral context only ‚Äî no predictions or guarantees.`;
    return sendTelegram(chatId, text);
  },

  // Members-only neutral odds view
  async odds({ chatId, args, user }) {
    if (!isPaid(user)) {
      return sendTelegram(chatId, `${ICONS.odds} Members-only. Signup: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}. See /signup or /pay.`);
    }

    if (args.length) {
      const [fixture] = args;
      const data = await ApiFootball.odds({ fixture }).catch(err => ({ error: err }));
      if (data.error) return sendTelegram(chatId, friendlyError(data.error, ICONS.odds + " Odds"));

      const markets = (data?.response?.[0]?.bookmakers ?? []).flatMap(b =>
        (b?.bets ?? []).map(m => {
          const line = `${b?.name} ‚Äî ${m?.name}: ${(m?.values ?? []).map(v => `${v?.value} ${v?.odd}`).join(" | ")}`;
          return escapeHtml(line);
        })
      );

      if (!markets.length) return sendTelegram(chatId, `${ICONS.odds} No odds found for fixture ${escapeHtml(fixture)}`);

      const totalPages = Math.max(1, Math.ceil(markets.length / PAGE_SIZE));
      const page = 0;
      await setList(chatId, `ODDS:${fixture}`, markets);
      await setPage(chatId, `ODDS:${fixture}`, page);

      const header = `${ICONS.odds} Neutral odds for fixture ${escapeHtml(fixture)} ${ICONS.pageInfo} Page ${page + 1}/${totalPages}`;
      const slice = markets.slice(page * PAGE_SIZE, page * PAGE_SIZE + PAGE_SIZE);
      const text = fmtList(header, slice) + `\n\nNeutral context only ‚Äî no predictions or guarantees.`;
      const kb = {
        inline_keyboard: [
          [{ text: "üîç Analyze", callback_data: `ANALYZE:${fixture}` }],
          [{ text: "üßæ Lineups", callback_data: `LINEUPS:${fixture}` }],
          [
            ...(page > 0 ? [{ text: `${ICONS.pagePrev} Prev`, callback_data: `PAGENAV:ODDS-${fixture}:${page - 1}` }] : []),
            ...(page + 1 < totalPages ? [{ text: `${ICONS.pageNext} Next`, callback_data: `PAGENAV:ODDS-${fixture}:${page + 1}` }] : [])
          ],
          [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }]
        ]
      };
      return sendTelegram(chatId, text, { reply_markup: kb });
    }

    const today = new Date().toISOString().slice(0, 10);
    const fx = await ApiFootball.fixturesByDate(today).catch(err => ({ error: err }));
    if (fx.error) return sendTelegram(chatId, friendlyError(fx.error, ICONS.odds + " Odds"));

    const od = await ApiFootball.oddsByDate(today).catch(err => ({ error: err }));
    if (od.error) return sendTelegram(chatId, friendlyError(od.error, ICONS.odds + " Odds"));

    const fixtureMap = new Map(
      (fx?.response ?? []).map(f => [f?.fixture?.id, {
        home: f?.teams?.home?.name,
        away: f?.teams?.away?.name
      }])
    );

    const rows = [];
    for (const entry of (od?.response ?? [])) {
      const fid = entry?.fixture?.id;
      const names = fixtureMap.get(fid) || {};
      const home = escapeHtml(entry?.teams?.home?.name ?? names.home ?? "Home");
      const away = escapeHtml(entry?.teams?.away?.name ?? names.away ?? "Away");
      for (const b of (entry?.bookmakers ?? [])) {
        for (const m of (b?.bets ?? [])) {
          const values = (m?.values ?? []).map(v => `${v?.value}: ${v?.odd}`).join(" | ");
          rows.push(`${home} vs ${away} ‚Äî ${escapeHtml(b?.name)} ${escapeHtml(m?.name)}: ${escapeHtml(values)}`);
          if (rows.length >= MAX_AGG_ROWS) break;
        }
        if (rows.length >= MAX_AGG_ROWS) break;
      }
      if (rows.length >= MAX_AGG_ROWS) break;
    }

    if (!rows.length) return sendTelegram(chatId, `${ICONS.odds} Neutral odds snapshot: none found for today.`);

    const totalPages = Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
    const page = 0;

    await setList(chatId, "ODDS_TODAY", rows);
    await setPage(chatId, "ODDS_TODAY", page);

    const header = `${ICONS.odds} Neutral odds snapshot for today ${ICONS.pageInfo} Page ${page + 1}/${totalPages}`;
    const slice = rows.slice(page * PAGE_SIZE, page * PAGE_SIZE + PAGE_SIZE);
    const text = fmtList(header, slice) + `\n\nNeutral context only ‚Äî no predictions or guarantees.`;
    const kb = universalNav(page, totalPages, "ODDS_TODAY");
    return sendTelegram(chatId, text, { reply_markup: kb });
  },

  // Members-only neutral analysis
  async analysis({ chatId, args, user }) {
    if (!isPaid(user)) {
      return sendTelegram(chatId, `${ICONS.analysis} Members-only. Signup: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}. See /signup or /pay.`);
    }

    const [leagueToken, seasonArg] = args.length >= 1 ? args : ["epl", defaultSeason()];
    const league = normLeagueId(leagueToken) || 39;
    const season = seasonArg || defaultSeason();

    const st = await ApiFootball.standings({ league, season }).catch(err => ({ error: err }));
    if (st.error) return sendTelegram(chatId, friendlyError(st.error, ICONS.analysis + " Analysis"));

    const table = (st?.response?.[0]?.league?.standings?.[0] ?? []).slice(0, 10);
    const pointsRange = table.length ? `${table[0]?.points}‚Äì${table[table.length - 1]?.points}` : "N/A";

    const lines = [
      `League ${escapeHtml(String(league))}, season ${escapeHtml(String(season))}`,
      `Top-10 points range: ${escapeHtml(pointsRange)}`
    ].concat(table.map(r => `${escapeHtml(r.rank)}. ${escapeHtml(r.team?.name)} ‚Äî ${escapeHtml(r.points)} pts (GD ${escapeHtml(r.goalsDiff)})`));
    const text = fmtList(`${ICONS.analysis} Neutral analysis`, lines) + `\n\nNeutral context only ‚Äî no predictions or guarantees.`;
    return sendTelegram(chatId, text);
  },

  async form({ chatId, args, user }) {
    if (!isPaid(user)) {
      return sendTelegram(chatId, `${ICONS.tips} Members-only. Signup: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}. See /signup or /pay.`);
    }
    const teamName = args.join(" ");
    if (!teamName) return sendTelegram(chatId, usage(`${ICONS.tips} Usage: /form <team name>`));

    return sendTelegram(chatId,
      `${ICONS.tips} Form (neutral):\n` +
      `Use /fixtures <league> <season> and scan recent matches for ${escapeHtml(teamName)}.\n` +
      `Advanced form view will be added post-AI integration.\n\n` +
      `Neutral context only ‚Äî no predictions or guarantees.`);
  },

  async headtohead({ chatId, args, user }) {
    if (!isPaid(user)) {
      return sendTelegram(chatId, `${ICONS.h2h} Members-only. Signup: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}. See /signup or /pay.`);
    }
    const [home, away] = args;
    if (!home || !away) return sendTelegram(chatId, usage(`${ICONS.h2h} Usage: /headtohead <home> <away>`));
    return sendTelegram(chatId,
      `${ICONS.h2h} Head-to-head (neutral):\n` +
      `Historical H2H will be added later with safe summaries.\n\n` +
      `Neutral context only ‚Äî no predictions or guarantees.`);
  },

  async lineups({ chatId, args, user }) {
    if (!isPaid(user)) {
      return sendTelegram(chatId, `${ICONS.lineups} Members-only. Signup: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}. See /signup or /pay.`);
    }
    const [fixture] = args;
    if (!fixture) return sendTelegram(chatId, usage(`${ICONS.lineups} Usage: /lineups <fixtureId>`));
    return sendTelegram(chatId,
      `${ICONS.lineups} Lineups for fixture ${escapeHtml(String(fixture))} will be integrated later. Use /live meanwhile.\n\n` +
      `Neutral context only ‚Äî no predictions or guarantees.`);
  },

  async news({ chatId }) {
    const text =
      `${ICONS.news} <b>News</b>\n` +
      `Neutral digest coming soon.\n` +
      `${pickOne(MEMES)}`;
    return sendTelegram(chatId, text);
  },

  async tips({ chatId }) {
    const points = [
      "Focus on verified schedules and official statuses.",
      "Review standings and recent performance without assuming outcomes.",
      "Avoid chasing losses; set time boundaries.",
      "Treat odds as information, not guarantees.",
      "Prefer enjoyable viewing angles over expectations."
    ];
    const text = fmtList(`${ICONS.tips} Neutral tips`, points) + `\n\nNeutral context only ‚Äî no predictions or guarantees.`;
    return sendTelegram(chatId, text);
  },

  async vvip({ chatId, user }) {
    if (!isVVIP(user)) {
      return sendTelegram(chatId, `${ICONS.vvip} VVIP-only. Upgrade via /signup and /pay (daily/weekly/monthly).`);
    }
    const text =
      `${ICONS.vvip} <b>VVIP overview</b>\n` +
      `- Personalized dashboards (neutral summaries)\n` +
      `- Daily digest\n` +
      `- Priority support\n\n` +
      `Neutral context only ‚Äî no predictions or ‚Äúfixed matches‚Äù.`;
    return sendTelegram(chatId, text);
  },

  async vvip_today({ chatId, user }) {
    if (!isVVIP(user)) {
      return sendTelegram(chatId, `${ICONS.vvip} VVIP-only. Upgrade via /signup and /pay.`);
    }
    const today = new Date().toISOString().slice(0, 10);
    const data = await ApiFootball.fixturesByDate(today).catch(err => ({ error: err }));
    if (data.error) return sendTelegram(chatId, friendlyError(data.error, ICONS.vvip + " Digest"));

    const rows = (data?.response ?? []);
    const totalPages = Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
    const page = 0;

    await setList(chatId, "VVIP_TODAY", rows);
    await setPage(chatId, "VVIP_TODAY", page);

    const text = listFixtures("VVIP digest ‚Äî today‚Äôs fixtures (neutral)", rows, page, totalPages);
    const kb = kbForFixtures(rows, page, totalPages, "VVIP_TODAY");
    return sendTelegram(chatId, text, { reply_markup: kb });
  },

  async vvip_matches({ chatId, user }) {
    if (!isVVIP(user)) {
      return sendTelegram(chatId, `${ICONS.vvip} VVIP-only. Upgrade via /signup and /pay.`);
    }
    return sendTelegram(chatId, `${ICONS.vvip} VVIP matches: curated list will appear here post-AI integration.`);
  },

  async vvip_digest({ chatId, user }) {
    if (!isVVIP(user)) {
      return sendTelegram(chatId, `${ICONS.vvip} VVIP-only. Upgrade via /signup and /pay.`);
    }
    return sendTelegram(chatId, `${ICONS.vvip} VVIP digest: daily neutral highlights coming soon.`);
  },

  async fixed({ chatId }) {
    return sendTelegram(chatId,
      `${ICONS.rules} We do not provide ‚Äúfixed matches‚Äù.\n` +
      `Ethical and safety constraints apply. Use /analysis and /tips for neutral context.`);
  }
};

// ---------- Callback router ----------
async function routeCallback({ callbackQuery, user }) {
  const id = callbackQuery.id;
  const chatId = callbackQuery.message?.chat?.id;
  const messageId = callbackQuery.message?.message_id;
  const data = String(callbackQuery.data || "");
  if (!chatId || !data) {
    return answerCallbackQuery(id, "No data.");
  }

  if (data.startsWith("PAY:")) {
    const selection = data.replace("PAY:", "");
    // Tiers only give info; actual method chosen below
    await answerCallbackQuery(id, "Tier selected.");
    const tierText = selection.startsWith("member")
      ? `Member: ${selection.endsWith("kes") ? `KES ${SIGNUP_FEE_KES}` : `USD ${SIGNUP_FEE_USD}`}`
      : (() => {
          const parts = selection.split(":"); // vvip:daily|weekly|monthly:kes|usd
          const tier = parts[1];
          if (tier === "daily") return `VVIP Daily ‚Äî KES ${VVIP_DAILY_KES} / USD ${VVIP_DAILY_USD}`;
          if (tier === "weekly") return `VVIP Weekly ‚Äî KES ${VVIP_WEEKLY_KES} / USD ${VVIP_WEEKLY_USD}`;
          return `VVIP Monthly ‚Äî KES ${VVIP_MONTHLY_KES} / USD ${VVIP_MONTHLY_USD}`;
        })();

    const text =
      `${ICONS.pay} <b>Selected tier</b>\n` +
      `${escapeHtml(tierText)}\n\n` +
      `Choose payment method below to proceed.`;
    const kb = {
      inline_keyboard: [
        [{ text: "M-Pesa (STK Push)", callback_data: "PAY_METHOD:mpesa" },
         { text: "PayPal (Card)", callback_data: "PAY_METHOD:paypal" }],
        [{ text: "Binance (Crypto)", callback_data: "PAY_METHOD:binance" }],
        [{ text: `üß≠ Back to signup`, callback_data: "SHOW_SIGNUP" }],
        [{ text: `üß≠ Back to menu`, callback_data: "SHOW_MENU" }],
      ]
    };
    await editMessageText(chatId, messageId, text, kb);
    return;
  }

  if (data.startsWith("PAY_METHOD:")) {
    const method = data.split(":")[1];
    await handlePayMethod(chatId, id, method, callbackQuery.from?.id);
    return;
  }

  if (data === "SHOW_SIGNUP") {
    await answerCallbackQuery(id, "Opening signup‚Ä¶");
    await handlers.signup({ chatId });
    return;
  }

  if (data === "SHOW_MENU") {
    await answerCallbackQuery(id, "Opening menu‚Ä¶");
    await handlers.menu({ chatId });
    return;
  }

  if (data === "MPESA_STK:open") {
    await answerCallbackQuery(id, "Prepare STK JSON");
    const text =
      `üßæ <b>M-Pesa STK Push (API form)</b>\n` +
      `Send as a message:\n` +
      `/mpesa_stk <amount> <phone2547XXXXXXXX>\n` +
      `Example:\n` +
      `/mpesa_stk 250 254712345678\n\n` +
      `We‚Äôll trigger STK and confirm via webhook.`;
    await sendTelegram(chatId, text);
    return;
  }

  if (data === "PAYPAL_ORDER:open") {
    await answerCallbackQuery(id, "Prepare Order JSON");
    const text =
      `üßæ <b>PayPal One-time (API form)</b>\n` +
      `Send as a message:\n` +
      `/paypal_order <amount> [currency]\n` +
      `Example:\n` +
      `/paypal_order 10 USD\n`;
    await sendTelegram(chatId, text);
    return;
  }

  if (data === "PAYPAL_SUB:open") {
    await answerCallbackQuery(id, "Prepare Subscription JSON");
    const text =
      `üîÅ <b>PayPal Subscription (API form)</b>\n` +
      `Send as a message:\n` +
      `/paypal_sub <planId>\n` +
      `Example:\n` +
      `/paypal_sub P-XXXXXXXX\n`;
    await sendTelegram(chatId, text);
    return;
  }

  // Refresh lists
  if (data.startsWith("REFRESH:")) {
    const [_, contextTag, pageStr] = data.split(":");
    const page = Number(pageStr);
    await answerCallbackQuery(id, "Refreshing‚Ä¶");

    let rows = [];
    try {
      if (contextTag === "LIVE") {
        const d = await ApiFootball.live();
        rows = d?.response ?? [];
      } else if (contextTag === "TODAY") {
        const today = new Date().toISOString().slice(0, 10);
        const d = await ApiFootball.fixturesByDate(today);
        rows = d?.response ?? [];
      } else if (contextTag === "NEXT") {
        const d = await ApiFootball.nextFixtures({ count: 10 });
        rows = d?.response ?? [];
      } else if (contextTag === "FIXT") {
        rows = await getList(chatId, "FIXT");
      } else if (contextTag === "VVIP_TODAY") {
        const today = new Date().toISOString().slice(0, 10);
        const d = await ApiFootball.fixturesByDate(today);
        rows = d?.response ?? [];
      } else if (contextTag === "ODDS_TODAY") {
        const today = new Date().toISOString().slice(0, 10);
        const d = await ApiFootball.oddsByDate(today);
        rows = (d?.response ?? []).slice(0, MAX_AGG_ROWS).map(o => escapeHtml(JSON.stringify(o))).slice(0, MAX_AGG_ROWS);
      }
    } catch (err) {
      await editMessageText(chatId, messageId, friendlyError(err, "Refresh"), undefined);
      return;
    }

    const totalPages = Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
    const safePage = Math.max(0, Math.min(page, totalPages - 1));
    await setList(chatId, contextTag, rows);
    await setPage(chatId, contextTag, safePage);

    let text;
    let kb;
    if (contextTag === "LIVE") {
      text = listLive("Live now", rows, safePage, totalPages);
      kb = kbForFixtures(rows, safePage, totalPages, "LIVE");
    } else {
      const titles = {
        TODAY: "Today‚Äôs fixtures",
        NEXT: "Upcoming fixtures",
        FIXT: "Fixtures league view",
        VVIP_TODAY: "VVIP digest ‚Äî today‚Äôs fixtures (neutral)",
        ODDS_TODAY: "Neutral odds snapshot (refresh)"
      };
      text = listFixtures(titles[contextTag] || "Fixtures", rows, safePage, totalPages);
      kb = kbForFixtures(rows, safePage, totalPages, contextTag);
    }
    await editMessageText(chatId, messageId, text, kb);
    return;
  }

  // Pagination
  if (data.startsWith("PAGENAV:")) {
    const [_, contextTag, pageStr] = data.split(":");
    const page = Number(pageStr);
    await answerCallbackQuery(id, `Navigating to page ${page + 1}‚Ä¶`);

    if (contextTag.startsWith("ODDS-")) {
      const fixture = contextTag.split("-")[1];
      const list = await getList(chatId, `ODDS:${fixture}`);
      const totalPages = Math.max(1, Math.ceil(list.length / PAGE_SIZE));
      const safePage = Math.max(0, Math.min(page, totalPages - 1));
      await setPage(chatId, `ODDS:${fixture}`, safePage);

      const header = `${ICONS.odds} Neutral odds for fixture ${escapeHtml(String(fixture))} ${ICONS.pageInfo} Page ${safePage + 1}/${totalPages}`;
      const slice = list.slice(safePage * PAGE_SIZE, safePage * PAGE_SIZE + PAGE_SIZE);
      const text = fmtList(header, slice) + `\n\nNeutral context only ‚Äî no predictions or guarantees.`;
      const kb = universalNav(safePage, totalPages, `ODDS-${fixture}`);
      await editMessageText(chatId, messageId, text, kb);
      return;
    }

    const list = await getList(chatId, contextTag);
    const totalPages = Math.max(1, Math.ceil(list.length / PAGE_SIZE));
    const safePage = Math.max(0, Math.min(page, totalPages - 1));
    await setPage(chatId, contextTag, safePage);

    let text;
    let kb;
    if (contextTag === "LIVE") {
      text = listLive("Live now", list, safePage, totalPages);
      kb = kbForFixtures(list, safePage, totalPages, "LIVE");
    } else {
      const titles = {
        TODAY: "Today‚Äôs fixtures",
        NEXT: "Upcoming fixtures",
        FIXT: "Fixtures league view",
        VVIP_TODAY: "VVIP digest ‚Äî today‚Äôs fixtures (neutral)"
      };
      text = listFixtures(titles[contextTag] || "Fixtures", list, safePage, totalPages);
      kb = kbForFixtures(list, safePage, totalPages, contextTag);
    }
    await editMessageText(chatId, messageId, text, kb);
    return;
  }

  // Fixture actions
  const [action, arg] = data.split(":");
  if (!action || !arg) {
    return answerCallbackQuery(id, "Invalid action.");
  }

  switch (action) {
    case "ANALYZE":
      await answerCallbackQuery(id, "Analyzing fixture‚Ä¶");
      // Simple neutral snapshot; can be extended
      const league = 39;
      const season = defaultSeason();
      const st = await ApiFootball.standings({ league, season }).catch(() => null);
      const top = st?.response?.[0]?.league?.standings?.[0]?.slice(0, 10) ?? [];
      return sendTelegram(chatId,
        `${ICONS.analysis} <b>Neutral analysis</b>\n` +
        `Fixture ID: ${escapeHtml(String(arg))}\n` +
        `League sample: EPL top-10 snapshot:\n` +
        top.map(r => `- ${escapeHtml(r.team?.name)} (${escapeHtml(String(r.points))} pts)`).join("\n") +
        `\nNeutral context only ‚Äî no predictions or guarantees.`);
    case "ODDS":
      await answerCallbackQuery(id, "Fetching neutral odds‚Ä¶");
      return handlers.odds({ chatId, args: [arg], user });
    case "LINEUPS":
      await answerCallbackQuery(id, "Lineups coming soon‚Ä¶");
      return sendTelegram(chatId, `${ICONS.lineups} Lineups for fixture ${escapeHtml(String(arg))} will be integrated later. Use /live meanwhile.`);
    default:
      return answerCallbackQuery(id, "Unsupported action.");
  }
}

// ---------- Fallback ----------
async function fallbackReply(chatId, text) {
  const msg =
    `${ICONS.menu} Unknown or unsupported command: ${escapeHtml(text)}\n` +
    `Use /menu for the icon guide or /help.\n` +
    `Note: We refuse ‚Äúfixed matches‚Äù requests.`;
  return sendTelegram(chatId, msg);
}

// ---------- Main loop ----------
console.log(`${SERVICE_NAME || "Worker"} connected to Redis, waiting for jobs...`);

(async () => {
  while (true) {
    try {
      const job = await redis.brpop("telegram-jobs", 0);
      if (!job) continue;
      const [, raw] = job;

      let payload;
      try {
        const parsed = JSON.parse(raw);
        payload = parsed.payload ?? parsed;
      } catch (err) {
        console.error("[Parse] invalid job payload:", err.message);
        continue;
      }

      // Callback queries
      const cb = payload?.callback_query ?? null;
      if (cb) {
        const fromId = cb.from?.id;
        let user = await getUser(fromId);
        if (!user) {
          user = await putUser(fromId, { role: ROLE_FREE, created_at: Date.now() });
        }
        await routeCallback({ callbackQuery: cb, user });
        continue;
      }

      // Messages (text and edited text)
      const msg = payload?.message ?? payload?.edited_message ?? null;
      if (!msg?.chat?.id || !msg?.text) {
        console.warn("[Skip] missing chat/text in payload");
        continue;
      }

      const chatId = msg.chat.id;
      const fromId = msg.from?.id || chatId;

      // Referral deep link: /start <code>
      const entities = msg.entities || [];
      const hasBotCommand = entities.some(e => e.type === "bot_command");
      if (hasBotCommand && msg.text.startsWith("/start ")) {
        const code = normalizeTextSpaces(msg.text).split(" ").slice(1).join(" ").trim();
        if (code) await applyReferral(code, fromId);
      }

      let user = await getUser(fromId);
      if (!user) {
        user = await putUser(fromId, { role: ROLE_FREE, created_at: Date.now() });
      }

      const text = msg.text.trim();
      console.log("Telegram update received:", {
        update_id: payload.update_id,
        message: { message_id: msg.message_id, chat: msg.chat, date: msg.date, text: msg.text, entities: msg.entities }
      });

      // Command router with extended payments
      const { cmd, args } = parseArgs(text);

      // Admin
      if (cmd === "/approve") { await handlers.approve({ chatId, args }); continue; }
      if (cmd === "/approvevvip") { await handlers.approvevvip({ chatId, args }); continue; }
      if (cmd === "/force_role") { await handlers.force_role({ chatId, args }); continue; }
      if (cmd === "/audit") { await handlers.audit({ chatId, args }); continue; }

      // Payment commands (API-trigger style)
      if (cmd === "/mpesa_stk") {
        const [amountStr, phone] = args;
        const amount = Number(amountStr);
        if (!amount || !phone) {
          await sendTelegram(chatId, usage(`${ICONS.pay} Usage: /mpesa_stk <amount> <phone2547XXXXXXXX>`));
        } else {
          await initiateMpesaStk(chatId, amount, phone, "BETRIX", "BETRIX VVIP Payment", fromId);
        }
        continue;
      }

      if (cmd === "/paypal_order") {
        const [amountStr, currency] = args;
        const amount = Number(amountStr);
        if (!amount) {
          await sendTelegram(chatId, usage(`${ICONS.pay} Usage: /paypal_order <amount> [currency]`));
        } else {
          await initiatePaypalOrder(chatId, amount, currency || "USD", "BETRIX Payment");
        }
        continue;
      }

      if (cmd === "/paypal_sub") {
        const [planId] = args;
        if (!planId) {
          await sendTelegram(chatId, usage(`${ICONS.pay} Usage: /paypal_sub <planId>`));
        } else {
          await initiatePaypalSubscription(chatId, planId);
        }
        continue;
      }

      // Core router
      const paid = isPaid(user);
      const vvip = isVVIP(user);

      const known = new Set([
        "/start", "/menu", "/help", "/about", "/rules", "/contact", "/support",
        "/pricing", "/signup", "/pay", "/status", "/redeem",
        "/live", "/today", "/next", "/fixtures", "/standings",
        "/odds", "/analysis", "/form", "/headtohead", "/lineups", "/news", "/tips",
        "/vvip", "/vvip_today", "/vvip_matches", "/vvip_digest",
        "/refer", "/rewards", "/leaderboard",
        "/free_odds", "/strategy",
        "/fixed"
      ]);

      if (!known.has(cmd)) {
        await fallbackReply(chatId, text);
        continue;
      }

      if (gateFreeCommands(cmd)) {
        switch (cmd) {
          case "/start":       await handlers.start({ chatId }); break;
          case "/menu":        await handlers.menu({ chatId }); break;
          case "/help":        await handlers.help({ chatId }); break;
          case "/about":       await handlers.about({ chatId }); break;
          case "/rules":       await handlers.rules({ chatId }); break;
          case "/contact":     await handlers.contact({ chatId }); break;
          case "/support":     await handlers.support({ chatId }); break;
          case "/pricing":     await handlers.pricing({ chatId }); break;
          case "/signup":      await handlers.signup({ chatId }); break;
          case "/pay":         await handlers.pay({ chatId }); break;
          case "/status":      await handlers.status({ chatId, user }); break;
          case "/live":        await handlers.live({ chatId }); break;
          case "/today":       await handlers.today({ chatId, args }); break;
          case "/next":        await handlers.next({ chatId, args }); break;
          case "/fixtures":    await handlers.fixtures({ chatId, args }); break;
          case "/standings":   await handlers.standings({ chatId, args }); break;
          case "/news":        await handlers.news({ chatId }); break;
          case "/tips":        await handlers.tips({ chatId }); break;
          case "/refer":       await handlers.refer({ chatId, user, fromId }); break;
          case "/rewards":     await handlers.rewards({ chatId, user }); break;
          case "/leaderboard": await handlers.leaderboard({ chatId, fromId }); break;
          case "/free_odds":   await handlers.free_odds({ chatId, user: { ...user, id: fromId } }); break;
          case "/strategy":    await handlers.strategy({ chatId }); break;
          case "/fixed":       await handlers.fixed({ chatId }); break;
          default:             await fallbackReply(chatId, text);
        }
        continue;
      }

      if (cmd === "/redeem") {
        await handlers.redeem({ chatId, args, fromId });
        continue;
      }

      if (gateMemberCommands(cmd)) {
        if (!paid) {
          await sendTelegram(chatId, `${ICONS.pricing} Members-only. Signup: KES ${SIGNUP_FEE_KES} / USD ${SIGNUP_FEE_USD}. See /signup or /pay.`);
          continue;
        }
        switch (cmd) {
          case "/odds":        await handlers.odds({ chatId, args, user }); break;
          case "/analysis":    await handlers.analysis({ chatId, args, user }); break;
          case "/form":        await handlers.form({ chatId, args, user }); break;
          case "/headtohead":  await handlers.headtohead({ chatId, args, user }); break;
          case "/lineups":     await handlers.lineups({ chatId, args, user }); break;
          case "/markets":     await handlers.odds({ chatId, args, user }); break;
          case "/schedule":    await handlers.today({ chatId, args }); break;
          case "/injuries":    await sendTelegram(chatId, `${ICONS.lineups} Injuries: integrated later. Use /lineups or /live for current context.`); break;
          default:             await fallbackReply(chatId, text);
        }
        continue;
      }

      if (gateVVIPCommands(cmd)) {
        if (!vvip) {
          await sendTelegram(chatId, `${ICONS.vvip} VVIP-only. Upgrade via /signup and /pay.`);
          continue;
        }
        switch (cmd) {
          case "/vvip":          await handlers.vvip({ chatId, user }); break;
          case "/vvip_today":    await handlers.vvip_today({ chatId, user }); break;
          case "/vvip_matches":  await handlers.vvip_matches({ chatId, user }); break;
          case "/vvip_digest":   await handlers.vvip_digest({ chatId, user }); break;
          default:               await fallbackReply(chatId, text);
        }
        continue;
      }

      await fallbackReply(chatId, text);
    } catch (err) {
      console.error("[Worker] loop error:", err.message);
      await sleep(400);
    }
  }
})();

// ---------- Webhook consumption (M-Pesa & PayPal) via Redis inbox ----------
// If you expose HTTP elsewhere, pipe webhook payloads into Redis lists and consume here.
// Example publishers should push JSON payloads to:
// - "webhook:mpesa"
// - "webhook:paypal"

(async () => {
  // M-Pesa webhook consumer
  while (true) {
    try {
      const job = await redis.brpop("webhook:mpesa", 0);
      if (!job) continue;
      const [, raw] = job;
      let body;
      try { body = JSON.parse(raw); } catch { body = {}; }
      const cb = body?.Body?.stkCallback;
      const resultCode = cb?.ResultCode;
      const resultDesc = cb?.ResultDesc;
      const items = cb?.CallbackMetadata?.Item || [];

      const amount = items.find(i => i.Name === "Amount")?.Value;
      const phoneNumber = items.find(i => i.Name === "PhoneNumber")?.Value;
      const receipt = items.find(i => i.Name === "MpesaReceiptNumber")?.Value;

      const success = Number(resultCode) === 0;
      const adminId = ADMIN_TELEGRAM_ID;
      const msg =
        (success ? '‚úÖ <b>M-Pesa Payment Successful</b>' : '‚ùå <b>M-Pesa Payment Failed</b>') + "\n" +
        `Result: ${escapeHtml(String(resultDesc))}\n` +
        `Amount: ${escapeHtml(String(amount || 'N/A'))}\n` +
        `Phone: ${escapeHtml(String(phoneNumber || 'N/A'))}\n` +
        `Receipt: ${escapeHtml(String(receipt || 'N/A'))}\n`;

      if (adminId) await sendTelegram(adminId, msg);
      // TODO: Map webhook data to user and grant role automatically.
    } catch (e) {
      console.error("[Webhook:mpesa] error:", e.message);
      await sleep(250);
    }
  }
})();

(async () => {
  // PayPal webhook consumer
  while (true) {
    try {
      const job = await redis.brpop("webhook:paypal", 0);
      if (!job) continue;
      const [, raw] = job;
      let event;
      try { event = JSON.parse(raw); } catch { event = {}; }

      const headersOk = verifyPaypalWebhookHeaders(event?.headers || {});
      const type = event?.body?.event_type || "UNKNOWN";
      const adminId = ADMIN_TELEGRAM_ID;

      if (!headersOk) {
        if (adminId) await sendTelegram(adminId, `‚ö†Ô∏è PayPal webhook headers missing/invalid.`);
      } else {
        if (adminId) await sendTelegram(adminId, `üîî <b>PayPal</b> ${escapeHtml(type)}\n${escapeHtml(JSON.stringify(event.body || {}, null, 2))}`);
        // Examples:
        // - BILLING.SUBSCRIPTION.ACTIVATED -> grant VVIP
        // - PAYMENT.SALE.COMPLETED -> mark order paid
        // TODO: Map to user ledger and auto-grant roles.
      }
    } catch (e) {
      console.error("[Webhook:paypal] error:", e.message);
      await sleep(250);
    }
  }
})();